<!DOCTYPE html>
<html data-bs-theme="dark" lang="en" style="--bs-body-bg: #2b3036fa;--bs-primary: #A239CA;--bs-primary-rgb: 162,57,202;--bs-secondary: #4317F6;--bs-secondary-rgb: 67,23,246;--bs-body-color: #e7dfdd;color: rgb(255,255,255);">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>Lars Intro - Make your own Linear Algebra Library</title>
    <meta name="description" content="Make your own LA library

">
    <meta property="og:image" content="../assets/img/lars2.png">
    <link rel="stylesheet" href="../assets/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/css/bss-overrides.css">
    <link rel="stylesheet" href="../assets/css/Navbar-Right-Links-Dark-icons.css">
    <link rel="stylesheet" href="../assets/css/styles.css">
</head>

<body>
    <nav class="navbar navbar-expand-md bg-dark bg-opacity-50 rounded-4 shadow-sm" style="background: rgba(255,255,255,0);--bs-body-bg: #;" data-bs-theme="dark">
        <div class="container-fluid"><button data-bs-toggle="collapse" class="navbar-toggler" data-bs-target="#navcol-1"><span class="visually-hidden">Toggle navigation</span><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navcol-1">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link active" href="/">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/projects">Projects</a></li>
                    <li class="nav-item"><a class="nav-link" href="/articles">Articles</a></li>
                </ul>
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link active" href="/about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="/contact">Contact</a></li>
                </ul>
                <p class="navbar-text"><br>&nbsp;</p>
            </div>
        </div>
    </nav>
    <h1 style="color: rgb(255,255,255);">Linear Algebra from Scratch, A Guided Series</h1>
    <p style="color: rgb(255,255,255);">Welcome to the companion guides for the lars crate.<br><br>Alongside developing the crate itself, this series of articles is designed to help you build your own linear algebra functionality from the ground up. Each guide focuses on a small, well-defined task so you can learn and implement concepts step by step. The idea is to make the process approachable, modular, and transferable whether you want to follow the full series or just complete a few select parts.<br><br>.If you only need a 2D vector type, for example, you can complete the vector-related tasks and stop there. If you want to extend into 3D space or matrix transformations, you can build on top of what you’ve already written.<br><br>Each guide includes: - Mathematical background and conceptual explanations - Step-by-step implementation tasks - Full Rust code examples and solutions - Notes on extending or adapting the ideas further.<br><br>Although the examples are written in Rust, the core concepts can be adapted to any language with relative ease.</p>
    <h1 style="color: rgb(255,255,255);"><strong>Guides</strong></h1>
    <ul class="list-group">
        <li class="list-group-item">
            <h4 style="color: rgb(255,255,255);">Heading</h4><span style="color: rgb(255,255,255);">This page.</span>
        </li>
        <li class="list-group-item">
            <h4 style="color: rgb(255,255,255);">2. 2D Vector Guide</h4><span style="color: rgb(255,255,255);">Implement a simple two-dimensional vector type, including construction, arithmetic operations, scaling, dot products, and normalization.<br><a href="http://jayc.me/lars-site/vec2/"><span style="color: rgb(65, 131, 196);">Read it here: →</span></a></span>
        </li>
        <li class="list-group-item">
            <h4 style="color: rgb(255,255,255);">3. 3D Vector Guide (coming soon)</h4><span style="color: rgb(255,255,255);">Extend your 2D implementation into 3D space, introducing concepts such as the cross product and vector magnitude.</span>
        </li>
        <li class="list-group-item">
            <h4 style="color: rgb(255,255,255);">4. Matrix Guide (coming soon)</h4><span style="color: rgb(255,255,255);">Build a foundation for matrix operations, transformations, and composition.</span>
        </li>
        <li class="list-group-item">
            <h4>5. Practical Applications (planned)</h4><span style="color: rgb(255,255,255);">Apply your implementations in areas like computer graphics, physics simulations, or data transformations.</span>
        </li>
    </ul>
    <h1 style="color: rgb(255,255,255);"><br><strong>Modularity and Design Philosophy</strong></h1>
    <p style="color: rgb(255,255,255);">Each guide is written to be self-contained. You can treat them as individual learning modules or as chapters in a longer course. The goal is to make each piece useful on its own while still contributing to a larger, cohesive system.<br><br>This approach mirrors how the lars crate itself is structured: small, reusable components that can stand alone or combine to form a complete linear algebra library.<br><br></p>
    <h1 style="color: rgb(255,255,255);"><strong>Contributing and Next Steps</strong></h1>
    <p style="color: rgb(255,255,255);">The guides are a work in progress and will continue to grow alongside the crate. Contributions, feedback, and suggestions are welcome.<br><br>You can find the project on GitHub here:<br><a href="https://github.com/JCooper-Bit/lars">https://github.com/JCooper-Bit/lars</a><br>&nbsp; <br><br>These guides are written to teach by doing. Work through them in order, or pick the pieces you need, and you’ll have a solid understanding of the principles behind linear algebra, and the tools to implement them yourself.</p>
    <div data-bss-type="author-nav">
        <div class="author-jayceews" data-bss-type="author-loop-item">
            <div class="d-flex"><img class="img-fluid" width="240" height="160" src="../assets/img/Logo2.png">
                <div class="ps-3">
                    <h4><span style="color: rgb(255,255,255);">JayCee</span></h4>
                    <p style="color: rgb(255,255,255);">J. Cooper (JayCee) is a software developer, Maths enthusiast and musician based in the UK. They are the creator and maintainer of the lars crate and they have various other projects in progress

                        GitHub: @JCooper-Bit

                        Project Repo: lars on GitHub</p>
                </div>
            </div>
        </div>
    </div>
    <script>
        (function() {
            let collections = document.querySelectorAll('[data-bss-type="blog-loop"]');
            let tagNavs = document.querySelectorAll('[data-bss-type="tag-nav"]');
            let tagLoops = document.querySelectorAll('[data-bss-type="tag-loop"]');
            let authorLoops = document.querySelectorAll('[data-bss-type="author-loop"]');
            let authorNavs = document.querySelectorAll('[data-bss-type="author-nav"]');

            window.addEventListener("popstate", (e) => {
                for (let collection of collections) {
                    updateCollection(collection);
                }

                for (let tagNav of tagNavs) {
                    updateTagNav(tagNav);
                }

                for (let authorNav of authorNavs) {
                    updateAuthorNav(authorNav);
                }
            });

            for (let collection of collections) {

                updateCollection(collection);

                if (!canPaginateCollection(collection)) continue;

                let pagination = collection.querySelector('[data-bss-type="blog-loop-pagination"]');

                pagination.addEventListener('click', function(e) {
                    let paginationItem = e.target.closest('.page-item');
                    if (!paginationItem) return;

                    e.preventDefault();

                    if (paginationItem.classList.contains('disabled') || paginationItem.classList.contains('active')) return;

                    let collection = paginationItem.closest('[data-bss-type="blog-loop"]');
                    if (!collection) return;

                    let page = parseInt(paginationItem.dataset.page);
                    if (!page) return;

                    let pageParam = getPageParameter(collection);

                    if (pageParam) {
                        const url = new URL(window.location);
                        url.searchParams.set(pageParam, page);
                        history.pushState({
                            [pageParam]: page
                        }, document.title, url);

                        for (let c of collections) {
                            let param = getPageParameter(c);
                            if (param !== pageParam) continue;
                            updateCollection(c);
                        }
                    } else {
                        updateCollection(collection, page);
                    }
                });
            }

            for (let tagNav of tagNavs) {
                updateTagNav(tagNav);
                tagNav.addEventListener('click', onTagClick);
            }

            for (let tagLoop of tagLoops) {
                tagLoop.addEventListener('click', onTagClick);
            }

            for (let authorLoop of authorLoops) {
                authorLoop.addEventListener('click', onAuthorClick);
            }

            for (let authorNav of authorNavs) {
                updateAuthorNav(authorNav);
            }

            function onTagClick(e) {
                onBlogFilterClick(e);

                for (let nav of tagNavs) {
                    updateTagNav(nav);
                }
            }

            function onAuthorClick(e) {
                onBlogFilterClick(e);

                for (let authorNav of authorNavs) {
                    updateAuthorNav(authorNav);
                }
            }

            function onBlogFilterClick(e) {
                const item = e.target.closest('[data-bss-filter="blog"]');
                if (!item || !item.dataset.hasOwnProperty('bssHref') || !item.dataset.hasOwnProperty('bssFilterParam')) return;

                const stateNode = item.dataset.hasOwnProperty('bssStateNode') ? item : item.querySelector('[data-bss-state-node]');

                if (stateNode && (stateNode.classList.contains('disabled') || stateNode.classList.contains('active'))) {
                    e.preventDefault();
                    return;
                }

                const link = item.dataset.bssHref;
                if (!linksToCurrentPage(link)) return;

                e.preventDefault();

                const url = new URL(window.location);
                const filterParam = item.dataset.bssFilterParam;
                const filterValue = item.dataset.bssFilterValue || '';

                const collectionsToUpdate = [];
                const newQueryParams = {
                    [filterParam]: filterValue
                };

                for (let c of collections) {
                    if (!canFilterCollection(c)) continue;
                    collectionsToUpdate.push(c);

                    let pageParam = getPageParameter(c);
                    let page = url.searchParams.get(pageParam);
                    if (page === null || page == 1) continue;

                    newQueryParams[pageParam] = 1;
                }

                for (let param in newQueryParams) {
                    if (newQueryParams[param]) {
                        url.searchParams.set(param, newQueryParams[param]);
                    } else {
                        url.searchParams.delete(param);
                    }
                }

                history.pushState(newQueryParams, document.title, url);

                for (let c of collectionsToUpdate) {
                    updateCollection(c);
                }
            }

            function getCollectionFilters(collection) {
                let filters = [];

                try {
                    const parsed = JSON.parse(collection.dataset.bssFilters);

                    if (Array.isArray(parsed)) {
                        filters = parsed;
                    }
                } catch (e) {}

                return filters;
            }

            function getCollectionEmptyFilterAction(collection, filter = '') {
                let emptyFilterActions = [];

                try {
                    const parsed = JSON.parse(collection.dataset.bssEmptyFilterActions);

                    if (Array.isArray(parsed)) {
                        emptyFilterActions = parsed;
                    }
                } catch (e) {}

                const action = emptyFilterActions.find(action => action.filter === filter);

                return action ? action.value : '';
            }

            function canFilterCollection(collection) {
                return !!getCollectionFilters(collection).length;
            }

            function canFilterCollectionByTag(collection) {
                return getCollectionFilters(collection).includes('tag');
            }

            function canFilterCollectionByAuthor(collection) {
                return getCollectionFilters(collection).includes('author');
            }

            function shouldShowAllItemsForEmptyFilter(collection, filter = '') {
                return getCollectionEmptyFilterAction(collection, filter) === 'show-all';
            }

            function canPaginateCollection(collection) {
                return !!getCollectionPagination(collection);
            }

            function getCollectionPagination(collection) {
                return collection.querySelector('[data-bss-type="blog-loop-pagination"]');
            }

            function getPageParameter(collection) {
                return collection.dataset.bssPageParam;
            }

            function linksToCurrentPage(path = '') {
                let currentURL, url;

                try {
                    currentURL = new URL(window.location);
                    url = new URL(path, window.location.href);
                } catch (e) {
                    console.error(e);
                }

                return currentURL.origin === url.origin && currentURL.pathname === url.pathname;
            }

            function updateCollection(collection, page, activeTag = '', activeAuthor = '') {

                const url = new URL(window.location.href);

                if (canPaginateCollection(collection)) {
                    if (!page) {
                        let pageParam = getPageParameter(collection);
                        page = (pageParam ? url.searchParams.get(pageParam) : 1) || 1;
                    }
                }

                if (canFilterCollectionByTag(collection) && !activeTag) {
                    let tagParam = 'tag';
                    activeTag = url.searchParams.get(tagParam) || '';
                }

                if (canFilterCollectionByAuthor(collection) && !activeAuthor) {
                    let authorParam = 'author';
                    activeAuthor = url.searchParams.get(authorParam) || '';
                }

                renderCollectionPage(collection, page, activeTag, activeAuthor);
            }

            function renderCollectionPage(collection, page = 1, activeTag = '', activeAuthor = '') {

                page = Math.max(parseInt(page, 10), 1);

                collection.style.removeProperty('display');

                let loopBase = collection.querySelector('[data-bss-type="blog-loop-base"]');
                loopBase && loopBase.style.removeProperty('display');

                let emptyState = collection.querySelector('[data-bss-type="empty-state"]');
                emptyState && emptyState.style.setProperty('display', 'none', 'important');

                let listItems = [].slice.call(collection.querySelectorAll('[data-bss-type="blog-loop-item"]'));
                listItems.forEach(item => item.style.setProperty('display', 'none', 'important'));

                if (canFilterCollectionByTag(collection)) {
                    listItems = listItems.filter(item => activeTag ? item.classList.contains('post-tag-' + activeTag) : shouldShowAllItemsForEmptyFilter(collection, 'tag'));
                }

                if (canFilterCollectionByAuthor(collection)) {
                    listItems = listItems.filter(item => activeAuthor ? item.classList.contains('post-author-' + activeAuthor) : shouldShowAllItemsForEmptyFilter(collection, 'author'));
                }

                let perPage = collection.dataset.bssPerpage || listItems.length;
                let visibleListItems = listItems.slice((page - 1) * perPage, page * perPage);
                visibleListItems.forEach(item => item.style.removeProperty('display'));

                let isEmpty = !visibleListItems.length;

                if (isEmpty) {
                    loopBase && loopBase.style.setProperty('display', 'none', 'important');
                    emptyState && emptyState.style.removeProperty('display');
                }

                let itemCount = listItems.length;
                let pageCount = Math.max(Math.ceil(itemCount / perPage), 1);

                updateCollectionPagination(collection, page, pageCount, isEmpty);

                if (collection.dataset.bssScrollOnChange) {
                    scrollToCollectionTop(collection);
                }
            }

            function updateCollectionPagination(collection, page, pageCount, isEmpty) {
                let pagination = getCollectionPagination(collection);
                if (!pagination) return;

                let paginationItems = [].slice.call(pagination.querySelectorAll('.page-item'));

                if (pageCount === 1 || isEmpty) {
                    pagination.style.setProperty('display', 'none', 'important');
                } else {
                    pagination.style.removeProperty('display');
                }

                let previousBtnDisabled = page - 1 <= 0;
                let previousPage = previousBtnDisabled ? 1 : page - 1;

                let nextBtnDisabled = page + 1 > pageCount;
                let nextPage = nextBtnDisabled ? pageCount : page + 1;

                for (let i = 0; i < paginationItems.length; i++) {
                    let paginationItem = paginationItems[i];

                    paginationItem.classList.remove('active', 'disabled');

                    if (paginationItem.dataset.type === 'prev') {
                        paginationItem.dataset.page = previousPage;

                        if (previousBtnDisabled) {
                            paginationItem.classList.add('disabled');
                        }
                    } else if (paginationItem.dataset.type === 'next') {
                        paginationItem.dataset.page = nextPage;

                        if (nextBtnDisabled) {
                            paginationItem.classList.add('disabled');
                        }
                    } else {
                        if (paginationItem.dataset.page > pageCount) {
                            paginationItem.style.setProperty('display', 'none', 'important');
                        } else {
                            paginationItem.style.removeProperty('display');
                        }

                        if (paginationItem.dataset.page == page) {
                            paginationItem.classList.add('active');
                        }
                    }
                }
            }

            function scrollToCollectionTop(collection) {
                const rect = collection.getBoundingClientRect();
                const viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
                const threshold = 100;

                if (rect.top >= 0 && viewHeight - rect.top > threshold) return;

                setTimeout(() => {
                    collection.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                        inline: "start"
                    });
                }, 0);
            }

            function updateTagNav(tagNav) {
                const url = new URL(window.location.href);

                let tagParam = 'tag';
                let tag = url.searchParams.get(tagParam) || '';

                renderTagNav(tagNav, tag);
            }

            function renderTagNav(tagNav, activeTag = '') {
                if (!tagNav.dataset.bssSyncUrl) return;

                let navItems = [].slice.call(tagNav.querySelectorAll('[data-bss-type="tag-loop-item"]'));

                navItems.forEach(item => {
                    const activeClassNode = item.dataset.hasOwnProperty('bssStateNode') ? item : item.querySelector('[data-bss-state-node]');
                    if (!activeClassNode) return;

                    activeClassNode.classList.remove('active');

                    const link = item.dataset.bssHref;
                    if (!linksToCurrentPage(link) || activeClassNode.classList.contains('disabled')) return;

                    if (item.dataset.bssTag === activeTag) {
                        activeClassNode.classList.add('active');
                    }
                });
            }

            function updateAuthorNav(authorNav) {
                const url = new URL(window.location.href);

                let authorParam = 'author';
                let author = url.searchParams.get(authorParam) || '';

                renderAuthorNav(authorNav, author);
            }

            function renderAuthorNav(authorNav, activeAuthor = '') {
                if (!canFilterCollectionByAuthor(authorNav)) return;

                authorNav.style.removeProperty('display');

                let items = [].slice.call(authorNav.querySelectorAll('[data-bss-type="author-loop-item"]'));
                items.forEach(item => item.classList.contains('author-' + activeAuthor) ? item.style.removeProperty('display') : item.style.setProperty('display', 'none', 'important'));
            }
        })();
    </script>
    <script src="../assets/bootstrap/js/bootstrap.min.js"></script>
    <script src="../assets/js/bs-init.js"></script>
</body>

</html>